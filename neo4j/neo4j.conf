# Neo4j Performance Optimization Configuration
# ==================================================
# For production EFC graph with ~14k nodes
# Place in Neo4j conf directory (or docker-compose volume)

# ============================================================
# MEMORY CONFIGURATION
# ============================================================

# Heap size (Java heap for transactions and query execution)
# Recommendation: 2-4GB for ~14k nodes + 50k relations
dbms.memory.heap.initial_size=2G
dbms.memory.heap.max_size=2G

# Page cache (OS-level cache for graph storage)
# Recommendation: 2GB for ~14k nodes (~150MB on disk)
dbms.memory.pagecache.size=2G

# Transaction state (concurrent transaction memory)
dbms.memory.transaction.global_max_size=512M
dbms.memory.transaction.database_max_size=256M

# ============================================================
# PERFORMANCE TUNING
# ============================================================

# Bolt thread pool (concurrent connections)
dbms.connector.bolt.thread_pool_min_size=5
dbms.connector.bolt.thread_pool_max_size=400

# Transaction timeout (prevent long-running queries)
dbms.transaction.timeout=60s

# Query logging (log slow queries > 1s)
dbms.logs.query.enabled=true
dbms.logs.query.threshold=1s
dbms.logs.query.parameter_logging_enabled=true

# ============================================================
# VECTOR INDEX CONFIGURATION
# ============================================================

# Enable vector indexes for Concept embeddings
# (Applied via Cypher - see neo4j_optimize.py)

# Vector similarity settings
db.index.vector.ephemeral_graph_enabled=true

# ============================================================
# NETWORK & SECURITY
# ============================================================

# Bolt connector (default port 7687)
dbms.connector.bolt.enabled=true
dbms.connector.bolt.listen_address=0.0.0.0:7687

# HTTP connector (default port 7474)
dbms.connector.http.enabled=true
dbms.connector.http.listen_address=0.0.0.0:7474

# HTTPS connector (optional)
dbms.connector.https.enabled=false

# Allow connections from any host (for Docker)
dbms.connectors.default_listen_address=0.0.0.0

# ============================================================
# INDEXING & QUERY OPTIMIZATION
# ============================================================

# Enable cost-based query planner
cypher.planner=cost

# Enable runtime statistics
cypher.statistics_divergence_threshold=0.75

# Enable query caching
dbms.query_cache_size=1000

# ============================================================
# LOGGING
# ============================================================

# Log level (INFO for production, DEBUG for troubleshooting)
dbms.logs.default_level=INFO

# Log file rotation
dbms.logs.rotation.size=20m
dbms.logs.rotation.keep_number=5

# ============================================================
# DOCKER NOTES
# ============================================================

# When running in Docker, mount this file as:
# volumes:
#   - ./neo4j.conf:/var/lib/neo4j/conf/neo4j.conf
#
# Or set environment variables:
# environment:
#   - NEO4J_dbms_memory_heap_initial__size=2G
#   - NEO4J_dbms_memory_heap_max__size=2G
#   - NEO4J_dbms_memory_pagecache_size=2G

# ============================================================
# PRODUCTION CHECKLIST
# ============================================================

# 1. ✅ Memory: 2G heap + 2G pagecache
# 2. ✅ Indexes: Concept.name, Chunk.document, relation types
# 3. ✅ Vector indexes: Concept embeddings (1536 dims, cosine)
# 4. ✅ Query logging: Slow queries > 1s
# 5. ✅ Connection pool: 5-400 threads
# 6. ✅ Transaction timeout: 60s
# 7. ✅ Query cache: 1000 queries
# 8. ✅ Log rotation: 20MB, keep 5 files

# ============================================================
# RESTART REQUIRED
# ============================================================

# After changes, restart Neo4j:
# docker-compose restart neo4j
# OR
# systemctl restart neo4j
